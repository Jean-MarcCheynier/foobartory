import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';
import { RootState } from '../../app/store';
import * as API from './actionAPI';

import { IRobot  } from '../../interfaces/Robot';
import { Foobar } from '../../interfaces/Foobar';
import { Foo } from '../../interfaces/Foo';
import { Bar } from '../../interfaces/Bar';
import { rules } from './../../utils/rules';
import RobotFactory from './../../utils/RobotFactory';

export enum LineEnum {
  FOO_MINING = 'fooMining',
  BAR_MINING = 'barMining',
  FOOBAR_CRAFTING = 'foobarCrafting',
  SHOPPING = 'shopping',
  BENCH = 'bench'
}

export interface FactoryState {
  robotMap: { [robotId: string]: IRobot },
  line: {
    [LineEnum.FOO_MINING]: string[],
    [LineEnum.BAR_MINING]: string[],
    [LineEnum.FOOBAR_CRAFTING]: string[],
    [LineEnum.SHOPPING]: string[],
    [LineEnum.BENCH]: string[],

  },
  prod: {
    foo: Foo[],
    bar: Bar[],
    foobar: Foobar[]
  },
  workshop: {
    craft: {foos: Foo[], bars: Bar[]}[],
    craftAttempts: number
  }
}

const getInitialState = (): FactoryState => {
  const initialState:FactoryState  = {
    robotMap: {
    },
    line: {
      [LineEnum.FOO_MINING]: [],
      [LineEnum.BAR_MINING]: [],
      [LineEnum.FOOBAR_CRAFTING]: [],
      [LineEnum.SHOPPING]: [],
      [LineEnum.BENCH]: [],
    },
    prod: {
      foo: [],
      bar: [],
      foobar: [{}],
    },
    workshop: {
      craft: [],
      craftAttempts: 0
    }
  }

  for(let i =0; i < rules.NB_ROBOTS_START; i++) {
    let robot:IRobot = RobotFactory.createRobot();
    initialState.robotMap[robot.id] = robot;
    initialState.line[LineEnum.BENCH].push(robot.id)
  }

  return initialState
};

export const changeLine = createAsyncThunk(
  'action/changeLine',
  async (args: { robot: IRobot, line: LineEnum }) => {
    await API.changeLine();
    // The value we return becomes the `fulfilled` action payload
    return;
  }
);

export const mineFoo = createAsyncThunk(
  'action/mineFoo',
  async (args: { robot: IRobot }) => {
    const response = await API.mineFoo();
    // The value we return becomes the `fulfilled` action payload
    return response.data;
  }
);

export const mineBar = createAsyncThunk(
  'action/mineBar',
  async (args: { robot: IRobot }) => {
    const response = await API.mineBar();
    // The value we return becomes the `fulfilled` action payload
    return response.data;
  }
);

export const craftFoobar = createAsyncThunk(
  'action/craftFoobar',
  async (args: { robot: IRobot }) => {
    const response = await API.craftFoobar();
    // The value we return becomes the `fulfilled` action payload
    return response.data;
  }
);

export const buyRobot = createAsyncThunk(
  'action/buyRobot',
  async (args: { robot: IRobot }) => {
    const response = await API.buyRobot();
    // The value we return becomes the `fulfilled` action payload
    return response.data;
  }
);

export const factorySlice = createSlice({
  name: 'factory',
  initialState: getInitialState(),
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    reset: () => (getInitialState())
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      //Mine Foo Reducers
      .addCase(mineFoo.pending, (state, action) => {
        const { meta } = action;
        state.robotMap[meta.arg.robot.id].busy = true;
      })
      .addCase(mineFoo.fulfilled, (state, action) => {
        const { meta } = action;
        state.prod.foo = [...state.prod.foo, action.payload];
        state.robotMap[meta.arg.robot.id].busy = false;
      })
      //Mine Bar Reducers
      .addCase(mineBar.pending, (state, action) => {
        const { meta } = action;
        state.robotMap[meta.arg.robot.id].busy = true;
      })
      .addCase(mineBar.fulfilled, (state, action) => {
        const { meta } = action;
        state.prod.bar = [...state.prod.bar, action.payload];
        state.robotMap[meta.arg.robot.id].busy = false;
      })
      //Craft Foobar Reducers
      .addCase(craftFoobar.pending, (state, action) => {
        const { meta } = action;
        if(state.prod.bar.length < rules.FOOBAR_CRAFTING_PRICE_BAR || state.prod.bar.length < rules.FOOBAR_CRAFTING_PRICE_BAR) {
          throw Error("Cannot perform reducer craftFoobar")
        }else{
          const fooArray = state.prod.foo.splice(0, rules.FOOBAR_CRAFTING_PRICE_FOO);
          const barArray = state.prod.bar.splice(0, rules.FOOBAR_CRAFTING_PRICE_BAR);   
          state.workshop.craftAttempts++ 
          state.workshop.craft.push({foos: fooArray, bars: barArray }) 
          state.robotMap[meta.arg.robot.id].busy = true;
        }
      })
      .addCase(craftFoobar.fulfilled, (state, action) => {
        alert('Crafted')
        const { robot } = action.meta.arg;
        if(state.workshop.craft.length <= 0) {
          throw Error("No craft present in the workshop")
        }else{  
          state.workshop.craft.pop() 
          state.prod.foobar.push({});
          state.robotMap[robot.id].busy = false;
        }
      })
      .addCase(craftFoobar.rejected, (state, action) => {
        alert('Echec')
        const { robot } = action.meta.arg;
        if(state.workshop.craft.length <= 0) {
          throw Error("No craft present in the workshop")
        }else{  
          const failedCraft = state.workshop.craft.pop();
          const reusableFoos = failedCraft?.foos || []
          state.prod.foo = [ ...state.prod.foo, ...reusableFoos]
          state.robotMap[robot.id].busy = false;
        }
      })
      //Buy robot Line Reducers
      .addCase(buyRobot.fulfilled, (state, action) => {
        if(state.prod.foobar.length < rules.ROBOT_PRICE) {
          throw Error("No craft present in the workshop")
        }else{  
          const newRobot = RobotFactory.createRobot();
          state.robotMap[newRobot.id] = newRobot;
          state.line[LineEnum.BENCH].push(newRobot.id)
          state.prod.foobar.splice(0, rules.ROBOT_PRICE)
        }
      })
      //Change Line Reducers
      .addCase(changeLine.pending, (state, action) => {
        const { meta } = action;
        const { robot, line } = meta.arg;
        if(robot.activity) {
          state.line[robot.activity] = state.line[robot.activity].filter(id => id !== robot.id)
        }
        state.robotMap[robot.id] = { ...state.robotMap[robot.id], changingActivity: true, activity: undefined }
        state.line[line].push(robot.id)
      })
      .addCase(changeLine.fulfilled, (state, action) => {
        const { meta } = action;
        const { robot, line } = meta.arg;
        state.robotMap[robot.id] = { ...state.robotMap[robot.id], changingActivity: false, activity: line }
      })
  },
});

export const { reset } = factorySlice.actions;

export const selectFooMiners = (state: RootState): IRobot[] => {
  return state.factory.line[LineEnum.FOO_MINING]
    .map((robotId: string) => state.factory.robotMap[robotId])
}

export const selectBarMiners = (state: RootState): IRobot[] => {
  return state.factory.line[LineEnum.BAR_MINING]
    .map((robotId: string) => state.factory.robotMap[robotId])
}

export const selectFoobarCrafters = (state: RootState): IRobot[] => {
  return state.factory.line[LineEnum.FOOBAR_CRAFTING]
    .map((robotId: string) => state.factory.robotMap[robotId])
}

export const selectShoppers = (state: RootState): IRobot[]  => {
  return state.factory.line[LineEnum.SHOPPING]
    .map((robotId: string) => state.factory.robotMap[robotId])
}

export const selectBench = (state: RootState): IRobot[] => {
  return state.factory.line[LineEnum.BENCH]
    .map((robotId: string) => state.factory.robotMap[robotId])
}

export const selectProd = (state: RootState) => state.factory.prod;
export const selectWorkshop = (state: RootState) => state.factory.workshop;
export const selectAll = (state: RootState) => state.factory.robotMap;

export default factorySlice.reducer;
