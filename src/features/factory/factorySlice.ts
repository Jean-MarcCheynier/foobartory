import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';
import { RootState } from '../../app/store';
import * as API from './actionAPI';
import { IRobot  } from '../../interfaces/Robot';
import { Foobar } from '../../interfaces/Foobar';
import { Foo } from '../../interfaces/Foo';
import { Bar } from '../../interfaces/Bar';
import { rules } from './../../utils/rules';
import RobotFactory from './../../utils/RobotFactory';

export enum LineEnum {
  FOO_MINING = 'fooMining',
  BAR_MINING = 'barMining',
  FOOBAR_CRAFTING = 'foobarCrafting',
  SHOPPING = 'shopping',
  BENCH = 'benching'
}

export interface FactoryState {
  robotMap: { [robotId: string]: IRobot },
  line: {
    [LineEnum.FOO_MINING]: string[],
    [LineEnum.BAR_MINING]: string[],
    [LineEnum.FOOBAR_CRAFTING]: string[],
    [LineEnum.SHOPPING]: string[],
    [LineEnum.BENCH]: string[],

  },
  prod: {
    foo: Foo[],
    bar: Bar[],
    foobar: Foobar[]
  },
  workshop: {
    craft: {foos: Foo[], bars: Bar[]}[],
    craftAttempts: number
  }
}

const getInitialState = (): FactoryState => {
  const initialState:FactoryState  = {
    robotMap: {
    },
    line: {
      [LineEnum.FOO_MINING]: [],
      [LineEnum.BAR_MINING]: [],
      [LineEnum.FOOBAR_CRAFTING]: [],
      [LineEnum.SHOPPING]: [],
      [LineEnum.BENCH]: [],
    },
    prod: {
      foo: [],
      bar: [],
      foobar: [],
    },
    workshop: {
      craft: [],
      craftAttempts: 0
    }
  }

  for(let i =0; i < rules.NB_FOO_START; i++) {
    initialState.prod.foo.push({})
  }

  for(let i =0; i < rules.NB_BAR_START; i++) {
    initialState.prod.bar.push({})
  }

  for(let i =0; i < rules.NB_ROBOTS_START; i++) {
    let robot:IRobot = RobotFactory.createRobot();
    initialState.robotMap[robot.id] = robot;
    initialState.line[LineEnum.BENCH].push(robot.id)
  }

  return initialState
};

export const changeLine = createAsyncThunk(
  'action/changeLine',
  async (args: { robot: IRobot, line: LineEnum }) => {
    await API.changeLine();
    // The value we return becomes the `fulfilled` action payload
    return;
  }
);

export const mineFoo = createAsyncThunk(
  'action/mineFoo',
  async (args: { robot: IRobot }) => {
    const response = await API.mineFoo();
    // The value we return becomes the `fulfilled` action payload
    return response.data;
  }
);

export const mineBar = createAsyncThunk(
  'action/mineBar',
  async (args: { robot: IRobot }) => {
    const response = await API.mineBar();
    // The value we return becomes the `fulfilled` action payload
    return response.data;
  }
);

export const craftFoobar = createAsyncThunk(
  'action/craftFoobar',
  async (args: { robot: IRobot }, thunkAPI) => {
    const response = await API.craftFoobar();
    // The value we return becomes the `fulfilled` action payload
    return response.data;
  }
);

export const buyRobot = createAsyncThunk(
  'action/buyRobot',
  async (args: { robot: IRobot }) => {
    const response = await API.buyRobot();
    // The value we return becomes the `fulfilled` action payload
    return response.data;
  }
);

export const factorySlice = createSlice({
  name: 'factory',
  initialState: getInitialState(),
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    reset: () => (getInitialState())
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      //Mine Foo Reducers
      .addCase(mineFoo.pending, (state, action) => {
        const { robot: ref } = action.meta.arg;
        state.robotMap[ref.id].busy = true;
      })
      .addCase(mineFoo.fulfilled, (state, action) => {
        const { robot: ref } = action.meta.arg;
        state.prod.foo = [...state.prod.foo, action.payload];
        state.robotMap[ref.id].busy = false;
      })
      //Mine Bar Reducers
      .addCase(mineBar.pending, (state, action) => {
        const { robot: ref } = action.meta.arg;
        state.robotMap[ref.id].busy = true;
      })
      .addCase(mineBar.fulfilled, (state, action) => {
        const { robot: ref } = action.meta.arg;
        state.prod.bar = [...state.prod.bar, action.payload];
        state.robotMap[ref.id].busy = false;
      })
      //Craft Foobar Reducers
      .addCase(craftFoobar.pending, (state, action) => {
        const { robot: ref } = action.meta.arg;
        if(state.prod.bar.length < rules.FOOBAR_CRAFTING_PRICE_BAR || state.prod.bar.length < rules.FOOBAR_CRAFTING_PRICE_BAR) {
          throw Error("Cannot perform reducer craftFoobar")
        }else{
          const fooArray = state.prod.foo.splice(0, rules.FOOBAR_CRAFTING_PRICE_FOO);
          const barArray = state.prod.bar.splice(0, rules.FOOBAR_CRAFTING_PRICE_BAR);   
          state.workshop.craftAttempts++ 
          state.workshop.craft.push({foos: fooArray, bars: barArray }) 
          state.robotMap[ref.id].busy = true;
        }
      })
      .addCase(craftFoobar.fulfilled, (state, action) => {
        const { robot: ref } = action.meta.arg;
        if(state.workshop.craft.length <= 0) {
          throw Error("No craft present in the workshop")
        }else{  
          state.workshop.craft.pop() 
          state.prod.foobar.push({});
          state.robotMap[ref.id].busy = false;
        }
      })
      .addCase(craftFoobar.rejected, (state, action) => {
        const { robot } = action.meta.arg;
        if(state.workshop.craft.length <= 0) {
          throw Error("No craft present in the workshop")
        }else{  
          const failedCraft = state.workshop.craft.pop();
          if(failedCraft) {
            const reusableBar = failedCraft.bars
            state.prod.bar = [ ...state.prod.bar, ...reusableBar]
            state.robotMap[robot.id].busy = false;
          } else {
            throw new Error("Cannot reuse Bar")
          }

        }
      })
      //Buy robot Line Reducers
      .addCase(buyRobot.pending, (state, action) => { 
        state.prod.foobar.splice(0, rules.ROBOT_PRICE)       
      })
      .addCase(buyRobot.fulfilled, (state, action) => { 
        const newRobot = RobotFactory.createRobot();
        state.robotMap[newRobot.id] = newRobot;
        state.line[LineEnum.BENCH].push(newRobot.id)     
      })
      //Change Line Reducers
      .addCase(changeLine.pending, (state, action) => {
        const { robot: ref, line } = action.meta.arg;
        // Get the current robot state from robotMap
        const robot = state.robotMap[ref.id];
        if(robot.activity) {
          state.line[robot.activity] = state.line[robot.activity].filter(id => id !== robot.id)
        }
        state.robotMap[robot.id] = { ...state.robotMap[robot.id], changingActivity: true, activity: line }
        state.line[line].push(robot.id)
      })
      .addCase(changeLine.fulfilled, (state, action) => {
        const { robot: ref, line } = action.meta.arg;
        state.robotMap[ref.id] = { ...state.robotMap[ref.id], changingActivity: false, activity: line }
      })
  },
});

export const { reset } = factorySlice.actions;


/**Selectors **/
const selectLine = (state: RootState, line: LineEnum): IRobot[] => {
  return state.factory.line[line]
    .map((robotId: string) => state.factory.robotMap[robotId])
}
// Robot selectors
export const selectFooMiners = (state: RootState) => selectLine(state, LineEnum.FOO_MINING)
export const selectBarMiners = (state: RootState) => selectLine(state, LineEnum.BAR_MINING)
export const selectFoobarCrafters = (state: RootState) => selectLine(state, LineEnum.FOOBAR_CRAFTING)
export const selectShoppers = (state: RootState) => selectLine(state, LineEnum.SHOPPING)
export const selectBench = (state: RootState) => selectLine(state, LineEnum.BENCH)
export const selectAll = (state: RootState) => state.factory.robotMap;

// Production selector
export const selectProd = (state: RootState) => state.factory.prod;
export const selectWorkshop = (state: RootState) => state.factory.workshop;

// Constraint selectors
export type Constraint = (state: RootState) => boolean;
export const canCraftFoobar:Constraint =  (state: RootState) => (
  state.factory.prod.foo.length >= rules.FOOBAR_CRAFTING_PRICE_FOO && 
  state.factory.prod.bar.length >= rules.FOOBAR_CRAFTING_PRICE_BAR )
export const canBuyRobot:Constraint = (state: RootState) => ( state.factory.prod.foobar.length >= rules.ROBOT_PRICE )




export default factorySlice.reducer;
