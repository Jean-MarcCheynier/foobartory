import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';
import { RootState } from '../../app/store';
import * as API from './actionAPI';

import { IRobot  } from '../../interfaces/Robot';
import { Foobar } from '../../interfaces/Foobar';
import { Foo } from '../../interfaces/Foo';
import { Bar } from '../../interfaces/Bar';

export enum LineEnum {
  FOO_MINING = 'fooMining',
  BAR_MINING = 'barMining',
  FOOBAR_CRAFTING = 'foobarCrafting',
  SHOPPING = 'shopping' 
}

export interface FactoryState {
  robotMap: { [robotId: string]: IRobot },
  line: {
    [LineEnum.FOO_MINING]: string[],
    [LineEnum.BAR_MINING]: string[],
    [LineEnum.FOOBAR_CRAFTING]: string[],
    [LineEnum.SHOPPING]: string[]
  },
  prod: {
    foo: Foo[],
    bar: Bar[],
    foobar: Foobar[],
    robot: string[]
  }
}

const getInitialState = (): FactoryState => {
  const robot1: IRobot = { 'id': 'a', 'busy': false };
  const robot2: IRobot = { 'id': 'b', 'busy': false };
  return {
    robotMap: {
      [robot1.id]: robot1,
      [robot2.id]: robot2,
    },
    line: {
      [LineEnum.FOO_MINING]: [robot1.id, robot2.id],
      [LineEnum.BAR_MINING]: [],
      [LineEnum.FOOBAR_CRAFTING]: [],
      [LineEnum.SHOPPING]: []
    },
    prod: {
      foo: [],
      bar: [],
      foobar: [],
      robot: []
    }
  }
};

export const changeLine = createAsyncThunk(
  'action/changeLine',
  async (args: { robotId: string, line: LineEnum }) => {
    await API.changeLine();
    // The value we return becomes the `fulfilled` action payload
    return;
  }
);

export const mineFoo = createAsyncThunk(
  'action/mineFoo',
  async (args: { robot: IRobot }) => {
    const response = await API.mineFoo();
    // The value we return becomes the `fulfilled` action payload
    return response.data;
  }
);

export const mineBar = createAsyncThunk(
  'action/mineBar',
  async (args: { robot: IRobot }) => {
    const response = await API.mineBar();
    // The value we return becomes the `fulfilled` action payload
    return response.data;
  }
);

export const craftFoobar = createAsyncThunk(
  'action/craftFoobar',
  async (args: { robot: IRobot }) => {
    const response = await API.craftFoobar();
    // The value we return becomes the `fulfilled` action payload
    return response.data;
  }
);

export const buyRobot = createAsyncThunk(
  'action/buyRobot',
  async (args: { robot: IRobot }) => {
    const response = await API.buyRobot();
    // The value we return becomes the `fulfilled` action payload
    return response.data;
  }
);

export const factorySlice = createSlice({
  name: 'factory',
  initialState: getInitialState(),
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    reset: () => (getInitialState())
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      //Mine Foo Reducers
      .addCase(mineFoo.pending, (state, action) => {
        const { meta } = action;
        state.robotMap[meta.arg.robot.id].busy = true;
      })
      .addCase(mineFoo.fulfilled, (state, action) => {
        const { meta } = action;
        state.prod.foo = [...state.prod.foo, action.payload];
        state.robotMap[meta.arg.robot.id].busy = false;
      })
      .addCase(mineFoo.rejected, (state, action) => {
        const { meta } = action;
        state.robotMap[meta.arg.robot.id].busy = false;
      })
      //Mine Bar Reducers
      .addCase(mineBar.pending, (state, action) => {
        const { meta } = action;
        state.robotMap[meta.arg.robot.id].busy = true;
      })
      .addCase(mineBar.fulfilled, (state, action) => {
        const { meta } = action;
        state.prod.bar = [...state.prod.bar, action.payload];
        state.robotMap[meta.arg.robot.id].busy = false;
      })
      .addCase(mineBar.rejected, (state, action) => {
        const { meta } = action;
        state.robotMap[meta.arg.robot.id].busy = false;
      })
      //Change Line Bar Reducers
      .addCase(changeLine.pending, (state, action) => {
        const { meta } = action;
        const robotId = meta.arg.robotId;
        state.line[LineEnum.FOO_MINING] = state.line[LineEnum.FOO_MINING].filter( id => id !== robotId)
      })
      .addCase(changeLine.fulfilled, (state, action) => {
        const { meta } = action;
        const robotId = meta.arg.robotId;
        const destination = meta.arg.line;
        console.log(destination)
        state.line[destination].push(robotId)
      })
      .addCase(changeLine.rejected, (state, action) => {
        const { meta } = action;
        state.robotMap[meta.arg.robotId].busy = false;
      });
  },
});

export const { reset } = factorySlice.actions;

// The function below is called a selector and allows us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`
export const selectFooMiners = (state: RootState): IRobot[] => {
  return state.factory.line[LineEnum.FOO_MINING]
    .map((robotId: string) => state.factory.robotMap[robotId])
}

export const selectBarMiners = (state: RootState): IRobot[] => {
  return state.factory.line[LineEnum.BAR_MINING]
    .map((robotId: string) => state.factory.robotMap[robotId])
}

export const selectFoobarCrafters = (state: RootState): IRobot[] => {
  return state.factory.line[LineEnum.FOOBAR_CRAFTING]
    .map((robotId: string) => state.factory.robotMap[robotId])
}

export const selectShoppers = (state: RootState): IRobot[]  => {
  return state.factory.line[LineEnum.SHOPPING]
    .map((robotId: string) => state.factory.robotMap[robotId])
}

export const selectProd = (state: RootState) => state.factory.prod;

// We can also write thunks by hand, which may contain both sync and async logic.
// Here's an example of conditionally dispatching actions based on current state.

export default factorySlice.reducer;
